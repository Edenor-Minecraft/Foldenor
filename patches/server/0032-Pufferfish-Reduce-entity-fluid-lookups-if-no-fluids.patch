From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Thu, 4 Jan 2024 15:44:34 +0400
Subject: [PATCH] Pufferfish-Reduce-entity-fluid-lookups-if-no-fluids


diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index ce8c5354b0ebaeab77630d2caa61006274fe967d..a9049fa7c3c20cfa5c4b190098c26ffe54a826a7 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -9,6 +9,7 @@ import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
+
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -163,12 +164,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
     public boolean preserveMotion = true; // Paper - keep initial motion on first setPositionRotation
+
     static boolean isLevelAtLeast(CompoundTag tag, int level) {
         return tag.contains("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
     }
 
     // Paper start
     public static RandomSource SHARED_RANDOM = new RandomRandomSource();
+
     public static final class RandomRandomSource extends java.util.Random implements net.minecraft.world.level.levelgen.BitRandomSource { // Folia - region threading
         private boolean locked = false;
 
@@ -238,6 +241,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             return super.nextGaussian();
         }
     }
+
     // Paper end
     public org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason; // Paper
 
@@ -247,6 +251,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     public @org.jetbrains.annotations.Nullable net.minecraft.server.level.ChunkMap.TrackedEntity tracker; // Paper
     public @Nullable Throwable addedToWorldStack; // Paper - entity debug
+
     public CraftEntity getBukkitEntity() {
         if (this.bukkitEntity == null) {
             // Paper start - Folia schedulers
@@ -410,7 +415,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public final org.spigotmc.ActivationRange.ActivationType activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
     public final boolean defaultActivationState;
     public long activatedTick = Integer.MIN_VALUE;
-    public void inactiveTick() { }
+
+    public void inactiveTick() {
+    }
+
     // Spigot end
     // Paper start
     public long activatedImmunityTick = Integer.MIN_VALUE; // Paper
@@ -439,6 +447,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public UUID getOriginWorld() {
         return this.originWorld;
     }
+
     // Paper end
     public float getBukkitYaw() {
         return this.yRot;
@@ -447,6 +456,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public boolean isChunkLoaded() {
         return this.level.hasChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4);
     }
+
     // CraftBukkit end
     // Paper start
     public final AABB getBoundingBoxAt(double x, double y, double z) {
@@ -461,6 +471,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     private final boolean hardCollides;
 
     private static final java.util.Map<Class<? extends Entity>, Boolean> cachedOverrides = java.util.Collections.synchronizedMap(new java.util.WeakHashMap<>());
+
     {
         /* // Goodbye, broken on reobf...
         Boolean hardCollides = cachedOverrides.get(this.getClass());
@@ -510,6 +521,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     // Paper start - make end portalling safe
     public BlockPos portalBlock;
     public ServerLevel portalWorld;
+
     public void tickEndPortal() {
         BlockPos pos = this.portalBlock;
         ServerLevel world = this.portalWorld;
@@ -531,11 +543,12 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         event.callEvent();
 
         if (this instanceof ServerPlayer) {
-            ((ServerPlayer)this).changeDimension(worldserver, PlayerTeleportEvent.TeleportCause.END_PORTAL);
+            ((ServerPlayer) this).changeDimension(worldserver, PlayerTeleportEvent.TeleportCause.END_PORTAL);
             return;
         }
         this.teleportTo(worldserver, null);
     }
+
     // Paper end - make end portalling safe
     // Folia start
     private static final java.util.concurrent.ConcurrentHashMap<Class<? extends Entity>, Integer> CLASS_ID_MAP = new java.util.concurrent.ConcurrentHashMap<>();
@@ -545,6 +558,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     });
     private static final java.util.concurrent.atomic.AtomicLong REFERENCE_ID_GENERATOR = new java.util.concurrent.atomic.AtomicLong();
     public final long referenceId = REFERENCE_ID_GENERATOR.getAndIncrement();
+
     // Folia end
     // Folia start - region ticking
     public void updateTicks(long fromTickOffset, long fromRedstoneTimeOffset) {
@@ -703,7 +717,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         this.setRemoved(reason);
     }
 
-    public void onClientRemoval() {}
+    public void onClientRemoval() {
+    }
 
     public void setPose(net.minecraft.world.entity.Pose pose) {
         if (this.fixedPose) return; // Paper
@@ -822,7 +837,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     public void baseTick() {
         this.level().getProfiler().push("entityBaseTick");
-        if (firstTick && this instanceof net.minecraft.world.entity.NeutralMob neutralMob) neutralMob.tickInitialPersistentAnger(level); // Paper - Update last hurt when ticking
+        if (firstTick && this instanceof net.minecraft.world.entity.NeutralMob neutralMob)
+            neutralMob.tickInitialPersistentAnger(level); // Paper - Update last hurt when ticking
         this.feetBlockState = null;
         if (this.isPassenger() && this.getVehicle().isRemoved()) {
             this.stopRiding();
@@ -1087,221 +1103,221 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             this.moveVector = movement;
         }
         try {
-        // Paper end - detailed watchdog information
-        if (this.noPhysics) {
-            this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
-        } else {
-            this.wasOnFire = this.isOnFire();
-            if (movementType == MoverType.PISTON) {
-                this.activatedTick = Math.max(this.activatedTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20); // Paper
-                this.activatedImmunityTick = Math.max(this.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20);   // Paper
-                movement = this.limitPistonMovement(movement);
-                if (movement.equals(Vec3.ZERO)) {
-                    return;
+            // Paper end - detailed watchdog information
+            if (this.noPhysics) {
+                this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
+            } else {
+                this.wasOnFire = this.isOnFire();
+                if (movementType == MoverType.PISTON) {
+                    this.activatedTick = Math.max(this.activatedTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20); // Paper
+                    this.activatedImmunityTick = Math.max(this.activatedImmunityTick, io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + 20);   // Paper
+                    movement = this.limitPistonMovement(movement);
+                    if (movement.equals(Vec3.ZERO)) {
+                        return;
+                    }
                 }
-            }
 
-            this.level().getProfiler().push("move");
-            if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
-                movement = movement.multiply(this.stuckSpeedMultiplier);
-                this.stuckSpeedMultiplier = Vec3.ZERO;
-                this.setDeltaMovement(Vec3.ZERO);
-            }
-            // Paper start - ignore movement changes while inactive.
-            if (isTemporarilyActive && !(this instanceof ItemEntity || this instanceof net.minecraft.world.entity.vehicle.AbstractMinecart) && movement == getDeltaMovement() && movementType == MoverType.SELF) {
-                setDeltaMovement(Vec3.ZERO);
-                this.level.getProfiler().pop();
-                return;
-            }
-            // Paper end
+                this.level().getProfiler().push("move");
+                if (this.stuckSpeedMultiplier.lengthSqr() > 1.0E-7D) {
+                    movement = movement.multiply(this.stuckSpeedMultiplier);
+                    this.stuckSpeedMultiplier = Vec3.ZERO;
+                    this.setDeltaMovement(Vec3.ZERO);
+                }
+                // Paper start - ignore movement changes while inactive.
+                if (isTemporarilyActive && !(this instanceof ItemEntity || this instanceof net.minecraft.world.entity.vehicle.AbstractMinecart) && movement == getDeltaMovement() && movementType == MoverType.SELF) {
+                    setDeltaMovement(Vec3.ZERO);
+                    this.level.getProfiler().pop();
+                    return;
+                }
+                // Paper end
 
-            movement = this.maybeBackOffFromEdge(movement, movementType);
-            Vec3 vec3d1 = this.collide(movement);
-            double d0 = vec3d1.lengthSqr();
+                movement = this.maybeBackOffFromEdge(movement, movementType);
+                Vec3 vec3d1 = this.collide(movement);
+                double d0 = vec3d1.lengthSqr();
 
-            if (d0 > 1.0E-7D) {
-                if (this.fallDistance != 0.0F && d0 >= 1.0D) {
-                    BlockHitResult movingobjectpositionblock = this.level().clip(new ClipContext(this.position(), this.position().add(vec3d1), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this));
+                if (d0 > 1.0E-7D) {
+                    if (this.fallDistance != 0.0F && d0 >= 1.0D) {
+                        BlockHitResult movingobjectpositionblock = this.level().clip(new ClipContext(this.position(), this.position().add(vec3d1), ClipContext.Block.FALLDAMAGE_RESETTING, ClipContext.Fluid.WATER, this));
 
-                    if (movingobjectpositionblock.getType() != HitResult.Type.MISS) {
-                        this.resetFallDistance();
+                        if (movingobjectpositionblock.getType() != HitResult.Type.MISS) {
+                            this.resetFallDistance();
+                        }
                     }
-                }
 
-                try {
-                    this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
-                } catch (IllegalStateException e) {
-                    this.teleportAsync((ServerLevel) this.level(), this.position().add(vec3d1),
-                        this.getYRot(), this.getXRot(),
-                        Vec3.ZERO, PlayerTeleportEvent.TeleportCause.UNKNOWN,
-                        Entity.TELEPORT_FLAG_LOAD_CHUNK | Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
-                        null
-                    );
+                    try {
+                        this.setPos(this.getX() + vec3d1.x, this.getY() + vec3d1.y, this.getZ() + vec3d1.z);
+                    } catch (IllegalStateException e) {
+                        this.teleportAsync((ServerLevel) this.level(), this.position().add(vec3d1),
+                            this.getYRot(), this.getXRot(),
+                            Vec3.ZERO, PlayerTeleportEvent.TeleportCause.UNKNOWN,
+                            Entity.TELEPORT_FLAG_LOAD_CHUNK | Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
+                            null
+                        );
+                    }
                 }
-            }
-
-            this.level().getProfiler().pop();
-            this.level().getProfiler().push("rest");
-            boolean flag = !Mth.equal(movement.x, vec3d1.x);
-            boolean flag1 = !Mth.equal(movement.z, vec3d1.z);
-
-            this.horizontalCollision = flag || flag1;
-            this.verticalCollision = movement.y != vec3d1.y;
-            this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0D;
-            if (this.horizontalCollision) {
-                this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3d1);
-            } else {
-                this.minorHorizontalCollision = false;
-            }
-
-            this.setOnGroundWithKnownMovement(this.verticalCollisionBelow, vec3d1);
-            BlockPos blockposition = this.getOnPosLegacy();
-            BlockState iblockdata = this.level().getBlockState(blockposition);
 
-            this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
-            if (this.isRemoved()) {
                 this.level().getProfiler().pop();
-            } else {
-                if (this.horizontalCollision) {
-                    Vec3 vec3d2 = this.getDeltaMovement();
+                this.level().getProfiler().push("rest");
+                boolean flag = !Mth.equal(movement.x, vec3d1.x);
+                boolean flag1 = !Mth.equal(movement.z, vec3d1.z);
 
-                    this.setDeltaMovement(flag ? 0.0D : vec3d2.x, vec3d2.y, flag1 ? 0.0D : vec3d2.z);
+                this.horizontalCollision = flag || flag1;
+                this.verticalCollision = movement.y != vec3d1.y;
+                this.verticalCollisionBelow = this.verticalCollision && movement.y < 0.0D;
+                if (this.horizontalCollision) {
+                    this.minorHorizontalCollision = this.isHorizontalCollisionMinor(vec3d1);
+                } else {
+                    this.minorHorizontalCollision = false;
                 }
 
-                Block block = iblockdata.getBlock();
+                this.setOnGroundWithKnownMovement(this.verticalCollisionBelow, vec3d1);
+                BlockPos blockposition = this.getOnPosLegacy();
+                BlockState iblockdata = this.level().getBlockState(blockposition);
 
-                if (movement.y != vec3d1.y) {
-                    block.updateEntityAfterFallOn(this.level(), this);
-                }
+                this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
+                if (this.isRemoved()) {
+                    this.level().getProfiler().pop();
+                } else {
+                    if (this.horizontalCollision) {
+                        Vec3 vec3d2 = this.getDeltaMovement();
 
-                // CraftBukkit start
-                if (this.horizontalCollision && this.getBukkitEntity() instanceof Vehicle) {
-                    Vehicle vehicle = (Vehicle) this.getBukkitEntity();
-                    org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
-
-                    if (movement.x > vec3d1.x) {
-                        bl = bl.getRelative(BlockFace.EAST);
-                    } else if (movement.x < vec3d1.x) {
-                        bl = bl.getRelative(BlockFace.WEST);
-                    } else if (movement.z > vec3d1.z) {
-                        bl = bl.getRelative(BlockFace.SOUTH);
-                    } else if (movement.z < vec3d1.z) {
-                        bl = bl.getRelative(BlockFace.NORTH);
+                        this.setDeltaMovement(flag ? 0.0D : vec3d2.x, vec3d2.y, flag1 ? 0.0D : vec3d2.z);
                     }
 
-                    if (!bl.getType().isAir()) {
-                        VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(moveVector)); // Paper - Expose pre-collision velocity
-                        this.level.getCraftServer().getPluginManager().callEvent(event);
+                    Block block = iblockdata.getBlock();
+
+                    if (movement.y != vec3d1.y) {
+                        block.updateEntityAfterFallOn(this.level(), this);
                     }
-                }
-                // CraftBukkit end
 
-                if (this.onGround()) {
-                    block.stepOn(this.level(), blockposition, iblockdata, this);
-                }
+                    // CraftBukkit start
+                    if (this.horizontalCollision && this.getBukkitEntity() instanceof Vehicle) {
+                        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                        org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
+
+                        if (movement.x > vec3d1.x) {
+                            bl = bl.getRelative(BlockFace.EAST);
+                        } else if (movement.x < vec3d1.x) {
+                            bl = bl.getRelative(BlockFace.WEST);
+                        } else if (movement.z > vec3d1.z) {
+                            bl = bl.getRelative(BlockFace.SOUTH);
+                        } else if (movement.z < vec3d1.z) {
+                            bl = bl.getRelative(BlockFace.NORTH);
+                        }
 
-                Entity.MovementEmission entity_movementemission = this.getMovementEmission();
+                        if (!bl.getType().isAir()) {
+                            VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(moveVector)); // Paper - Expose pre-collision velocity
+                            this.level.getCraftServer().getPluginManager().callEvent(event);
+                        }
+                    }
+                    // CraftBukkit end
 
-                if (entity_movementemission.emitsAnything() && !this.isPassenger()) {
-                    double d1 = vec3d1.x;
-                    double d2 = vec3d1.y;
-                    double d3 = vec3d1.z;
+                    if (this.onGround()) {
+                        block.stepOn(this.level(), blockposition, iblockdata, this);
+                    }
 
-                    this.flyDist += (float) (vec3d1.length() * 0.6D);
-                    BlockPos blockposition1 = this.getOnPos();
-                    BlockState iblockdata1 = this.level().getBlockState(blockposition1);
-                    boolean flag2 = this.isStateClimbable(iblockdata1);
+                    Entity.MovementEmission entity_movementemission = this.getMovementEmission();
 
-                    if (!flag2) {
-                        d2 = 0.0D;
-                    }
+                    if (entity_movementemission.emitsAnything() && !this.isPassenger()) {
+                        double d1 = vec3d1.x;
+                        double d2 = vec3d1.y;
+                        double d3 = vec3d1.z;
 
-                    this.walkDist += (float) vec3d1.horizontalDistance() * 0.6F;
-                    this.moveDist += (float) Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3) * 0.6F;
-                    if (this.moveDist > this.nextStep && !iblockdata1.isAir()) {
-                        boolean flag3 = blockposition1.equals(blockposition);
-                        boolean flag4 = this.vibrationAndSoundEffectsFromBlock(blockposition, iblockdata, entity_movementemission.emitsSounds(), flag3, movement);
+                        this.flyDist += (float) (vec3d1.length() * 0.6D);
+                        BlockPos blockposition1 = this.getOnPos();
+                        BlockState iblockdata1 = this.level().getBlockState(blockposition1);
+                        boolean flag2 = this.isStateClimbable(iblockdata1);
 
-                        if (!flag3) {
-                            flag4 |= this.vibrationAndSoundEffectsFromBlock(blockposition1, iblockdata1, false, entity_movementemission.emitsEvents(), movement);
+                        if (!flag2) {
+                            d2 = 0.0D;
                         }
 
-                        if (flag4) {
-                            this.nextStep = this.nextStep();
-                        } else if (this.isInWater()) {
-                            this.nextStep = this.nextStep();
-                            if (entity_movementemission.emitsSounds()) {
-                                this.waterSwimSound();
+                        this.walkDist += (float) vec3d1.horizontalDistance() * 0.6F;
+                        this.moveDist += (float) Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3) * 0.6F;
+                        if (this.moveDist > this.nextStep && !iblockdata1.isAir()) {
+                            boolean flag3 = blockposition1.equals(blockposition);
+                            boolean flag4 = this.vibrationAndSoundEffectsFromBlock(blockposition, iblockdata, entity_movementemission.emitsSounds(), flag3, movement);
+
+                            if (!flag3) {
+                                flag4 |= this.vibrationAndSoundEffectsFromBlock(blockposition1, iblockdata1, false, entity_movementemission.emitsEvents(), movement);
                             }
 
-                            if (entity_movementemission.emitsEvents()) {
-                                this.gameEvent(GameEvent.SWIM);
+                            if (flag4) {
+                                this.nextStep = this.nextStep();
+                            } else if (this.isInWater()) {
+                                this.nextStep = this.nextStep();
+                                if (entity_movementemission.emitsSounds()) {
+                                    this.waterSwimSound();
+                                }
+
+                                if (entity_movementemission.emitsEvents()) {
+                                    this.gameEvent(GameEvent.SWIM);
+                                }
                             }
+                        } else if (iblockdata1.isAir()) {
+                            this.processFlappingMovement();
                         }
-                    } else if (iblockdata1.isAir()) {
-                        this.processFlappingMovement();
                     }
-                }
 
-                this.tryCheckInsideBlocks();
-                float f = this.getBlockSpeedFactor();
-
-                this.setDeltaMovement(this.getDeltaMovement().multiply((double) f, 1.0D, (double) f));
-                // Paper start - remove expensive streams from here
-                boolean noneMatch = true;
-                AABB fireSearchBox = this.getBoundingBox().deflate(1.0E-6D);
-                {
-                    int minX = Mth.floor(fireSearchBox.minX);
-                    int minY = Mth.floor(fireSearchBox.minY);
-                    int minZ = Mth.floor(fireSearchBox.minZ);
-                    int maxX = Mth.floor(fireSearchBox.maxX);
-                    int maxY = Mth.floor(fireSearchBox.maxY);
-                    int maxZ = Mth.floor(fireSearchBox.maxZ);
-                    fire_search_loop:
-                    for (int fz = minZ; fz <= maxZ; ++fz) {
-                        for (int fx = minX; fx <= maxX; ++fx) {
-                            for (int fy = minY; fy <= maxY; ++fy) {
-                                net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk)this.level.getChunkIfLoadedImmediately(fx >> 4, fz >> 4);
-                                if (chunk == null) {
-                                    // Vanilla rets an empty stream if all the chunks are not loaded, so noneMatch will be true
-                                    // even if we're in lava/fire
-                                    noneMatch = true;
-                                    break fire_search_loop;
-                                }
-                                if (!noneMatch) {
-                                    // don't do get type, we already know we're in fire - we just need to check the chunks
-                                    // loaded state
-                                    continue;
-                                }
+                    this.tryCheckInsideBlocks();
+                    float f = this.getBlockSpeedFactor();
+
+                    this.setDeltaMovement(this.getDeltaMovement().multiply((double) f, 1.0D, (double) f));
+                    // Paper start - remove expensive streams from here
+                    boolean noneMatch = true;
+                    AABB fireSearchBox = this.getBoundingBox().deflate(1.0E-6D);
+                    {
+                        int minX = Mth.floor(fireSearchBox.minX);
+                        int minY = Mth.floor(fireSearchBox.minY);
+                        int minZ = Mth.floor(fireSearchBox.minZ);
+                        int maxX = Mth.floor(fireSearchBox.maxX);
+                        int maxY = Mth.floor(fireSearchBox.maxY);
+                        int maxZ = Mth.floor(fireSearchBox.maxZ);
+                        fire_search_loop:
+                        for (int fz = minZ; fz <= maxZ; ++fz) {
+                            for (int fx = minX; fx <= maxX; ++fx) {
+                                for (int fy = minY; fy <= maxY; ++fy) {
+                                    net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk) this.level.getChunkIfLoadedImmediately(fx >> 4, fz >> 4);
+                                    if (chunk == null) {
+                                        // Vanilla rets an empty stream if all the chunks are not loaded, so noneMatch will be true
+                                        // even if we're in lava/fire
+                                        noneMatch = true;
+                                        break fire_search_loop;
+                                    }
+                                    if (!noneMatch) {
+                                        // don't do get type, we already know we're in fire - we just need to check the chunks
+                                        // loaded state
+                                        continue;
+                                    }
 
-                                BlockState type = chunk.getBlockStateFinal(fx, fy, fz);
-                                if (type.is(BlockTags.FIRE) || type.is(Blocks.LAVA)) {
-                                    noneMatch = false;
-                                    // can't break, we need to retain vanilla behavior by ensuring ALL chunks are loaded
+                                    BlockState type = chunk.getBlockStateFinal(fx, fy, fz);
+                                    if (type.is(BlockTags.FIRE) || type.is(Blocks.LAVA)) {
+                                        noneMatch = false;
+                                        // can't break, we need to retain vanilla behavior by ensuring ALL chunks are loaded
+                                    }
                                 }
                             }
                         }
                     }
-                }
-                if (noneMatch) {
-                    // Paper end - remove expensive streams from here
-                    if (this.remainingFireTicks <= 0) {
-                        this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                    if (noneMatch) {
+                        // Paper end - remove expensive streams from here
+                        if (this.remainingFireTicks <= 0) {
+                            this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                        }
+
+                        if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                            this.playEntityOnFireExtinguishedSound();
+                        }
                     }
 
-                    if (this.wasOnFire && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
-                        this.playEntityOnFireExtinguishedSound();
+                    if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
+                        this.setRemainingFireTicks(-this.getFireImmuneTicks());
                     }
-                }
 
-                if (this.isOnFire() && (this.isInPowderSnow || this.isInWaterRainOrBubble())) {
-                    this.setRemainingFireTicks(-this.getFireImmuneTicks());
+                    this.level().getProfiler().pop();
                 }
-
-                this.level().getProfiler().pop();
             }
-        }
-        // Paper start - detailed watchdog information
+            // Paper start - detailed watchdog information
         } finally {
             synchronized (this.posLock) { // Paper
                 this.moveVector = null;
@@ -1374,7 +1390,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     public BlockPos getOnPosLegacy() {
         return this.getOnPos(0.2F);
@@ -1481,7 +1499,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
         final List<AABB> potentialCollisionsBB = new java.util.ArrayList<>();
         final List<VoxelShape> potentialCollisionsVoxel = new java.util.ArrayList<>();
-        final double stepHeight = (double)this.maxUpStep();
+        final double stepHeight = (double) this.maxUpStep();
         final AABB collisionBox;
         final boolean onGround = this.onGround;
 
@@ -1506,9 +1524,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         }
 
         io.papermc.paper.util.CollisionUtil.getCollisions(
-                world, this, collisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
-                io.papermc.paper.util.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
-                null, null
+            world, this, collisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
+            io.papermc.paper.util.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+            null, null
         );
 
         if (potentialCollisionsVoxel.isEmpty() && potentialCollisionsBB.isEmpty()) {
@@ -1518,8 +1536,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         final Vec3 limitedMoveVector = io.papermc.paper.util.CollisionUtil.performCollisions(movement, currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
 
         if (stepHeight > 0.0
-                && (onGround || (limitedMoveVector.y != movement.y && movement.y < 0.0))
-                && (limitedMoveVector.x != movement.x || limitedMoveVector.z != movement.z)) {
+            && (onGround || (limitedMoveVector.y != movement.y && movement.y < 0.0))
+            && (limitedMoveVector.x != movement.x || limitedMoveVector.z != movement.z)) {
             Vec3 vec3d2 = io.papermc.paper.util.CollisionUtil.performCollisions(new Vec3(movement.x, stepHeight, movement.z), currBoundingBox, potentialCollisionsVoxel, potentialCollisionsBB);
             final Vec3 vec3d3 = io.papermc.paper.util.CollisionUtil.performCollisions(new Vec3(0.0, stepHeight, 0.0), currBoundingBox.expandTowards(movement.x, 0.0, movement.z), potentialCollisionsVoxel, potentialCollisionsBB);
 
@@ -1664,7 +1682,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     }
 
-    protected void onInsideBlock(BlockState state) {}
+    protected void onInsideBlock(BlockState state) {
+    }
 
     public void gameEvent(GameEvent event, @Nullable Entity entity) {
         this.level().gameEvent(entity, event, this.position);
@@ -1735,7 +1754,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         this.playSound(this.getSwimSound(), volume, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
     }
 
-    protected void onFlap() {}
+    protected void onFlap() {
+    }
 
     protected boolean isFlapping() {
         return false;
@@ -1956,7 +1976,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         this.gameEvent(GameEvent.SPLASH);
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     protected BlockState getBlockStateOnLegacy() {
         return this.level().getBlockState(this.getOnPosLegacy());
@@ -2021,7 +2043,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         }
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     public float getLightLevelDependentMagicValue() {
         return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())) : 0.0F;
@@ -2044,7 +2068,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         this.yo = y;
         this.zo = d4;
         this.setPos(d3, y, d4);
-        if (this.valid) this.level.getChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4); // CraftBukkit
+        if (this.valid)
+            this.level.getChunk((int) Math.floor(this.getX()) >> 4, (int) Math.floor(this.getZ()) >> 4); // CraftBukkit
     }
 
     public void moveTo(Vec3 pos) {
@@ -2118,12 +2143,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return d0 * d0 + d1 * d1 + d2 * d2;
     }
 
-    public void playerTouch(Player player) {}
+    public void playerTouch(Player player) {
+    }
 
     public void push(Entity entity) {
         if (!this.isPassengerOfSameVehicle(entity)) {
             if (!entity.noPhysics && !this.noPhysics) {
-                if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer)) return; // Paper
+                if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer))
+                    return; // Paper
                 double d0 = entity.getX() - this.getX();
                 double d1 = entity.getZ() - this.getZ();
                 double d2 = Mth.absMax(d0, d1);
@@ -2326,6 +2353,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         this.passengers = ImmutableList.copyOf(pass);
         return result;
     }
+
     // Paper end
     public boolean save(CompoundTag nbt) {
         return this.isPassenger() ? false : this.saveAsPassenger(nbt);
@@ -2715,7 +2743,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         // Paper start
         return this.spawnAtLocation(stack, yOffset, null);
     }
-    public record DefaultDrop(Item item, org.bukkit.inventory.ItemStack stack, @Nullable java.util.function.Consumer<ItemStack> dropConsumer) {
+
+    public record DefaultDrop(Item item, org.bukkit.inventory.ItemStack stack,
+                              @Nullable java.util.function.Consumer<ItemStack> dropConsumer) {
         public DefaultDrop(final ItemStack stack, final java.util.function.Consumer<ItemStack> dropConsumer) {
             this(stack.getItem(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(stack), dropConsumer);
         }
@@ -2728,6 +2758,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             }
         }
     }
+
     @Nullable
     public ItemEntity spawnAtLocation(ItemStack stack, float yOffset, @Nullable java.util.function.Consumer<? super ItemEntity> delayedAddConsumer) {
         // Paper end
@@ -2753,10 +2784,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             stack.setCount(0); // Paper - destroy this item - if this ever leaks due to game bugs, ensure it doesn't dupe
 
             entityitem.setDefaultPickUpDelay(); // Paper - diff on change (in dropConsumer)
-    // Paper start
+            // Paper start
             return this.spawnAtLocation(entityitem);
         }
     }
+
     @Nullable
     public ItemEntity spawnAtLocation(ItemEntity entityitem) {
         {
@@ -2798,7 +2830,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             final int maxY = Mth.floor(axisalignedbb.maxY);
             final int maxZ = Mth.floor(axisalignedbb.maxZ);
 
-            final net.minecraft.server.level.ServerChunkCache chunkProvider = (net.minecraft.server.level.ServerChunkCache)this.level.getChunkSource();
+            final net.minecraft.server.level.ServerChunkCache chunkProvider = (net.minecraft.server.level.ServerChunkCache) this.level.getChunkSource();
 
             long lastChunkKey = ChunkPos.INVALID_CHUNK_POS;
             net.minecraft.world.level.chunk.LevelChunk lastChunk = null;
@@ -2829,7 +2861,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                             continue;
                         }
 
-                        final AABB toCollide = axisalignedbb.move(-(double)fx, -(double)fy, -(double)fz);
+                        final AABB toCollide = axisalignedbb.move(-(double) fx, -(double) fy, -(double) fz);
 
                         final AABB singleAABB = collisionShape.getSingleAABBRepresentation();
                         if (singleAABB != null) {
@@ -2883,7 +2915,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         positionUpdater.accept(passenger, vec3d.x, vec3d.y + (double) passenger.getMyRidingOffset(this), vec3d.z);
     }
 
-    public void onPassengerTurned(Entity passenger) {}
+    public void onPassengerTurned(Entity passenger) {
+    }
 
     public float getMyRidingOffset(Entity vehicle) {
         return this.ridingOffset(vehicle);
@@ -2925,9 +2958,20 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                 return false;
             } else {
                 if (this.valid) { // Folia - region threading - suppress entire event logic during worldgen
-                // CraftBukkit start
-                if (entity.getBukkitEntity() instanceof Vehicle && this.getBukkitEntity() instanceof LivingEntity) {
-                    VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.getBukkitEntity());
+                    // CraftBukkit start
+                    if (entity.getBukkitEntity() instanceof Vehicle && this.getBukkitEntity() instanceof LivingEntity) {
+                        VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.getBukkitEntity());
+                        // Suppress during worldgen
+                        if (this.valid) {
+                            Bukkit.getPluginManager().callEvent(event);
+                        }
+                        if (event.isCancelled()) {
+                            return false;
+                        }
+                    }
+                    // CraftBukkit end
+                    // Spigot start
+                    org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent(this.getBukkitEntity(), entity.getBukkitEntity());
                     // Suppress during worldgen
                     if (this.valid) {
                         Bukkit.getPluginManager().callEvent(event);
@@ -2935,17 +2979,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                     if (event.isCancelled()) {
                         return false;
                     }
-                }
-                // CraftBukkit end
-                // Spigot start
-                org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent(this.getBukkitEntity(), entity.getBukkitEntity());
-                // Suppress during worldgen
-                if (this.valid) {
-                    Bukkit.getPluginManager().callEvent(event);
-                }
-                if (event.isCancelled()) {
-                    return false;
-                }
                 } // Folia - region threading - suppress entire event logic during worldgen
                 // Spigot end
                 if (this.isPassenger()) {
@@ -2980,6 +3013,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         // Paper start
         stopRiding(false);
     }
+
     public void stopRiding(boolean suppressCancellation) {
         // Paper end
         if (this.vehicle != null) {
@@ -3013,12 +3047,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                 this.passengers = ImmutableList.copyOf(list);
             }
 
-            if (!passenger.hasNullCallback()) this.gameEvent(GameEvent.ENTITY_MOUNT, passenger); // Folia - region threading - do not fire game events for entities not added
+            if (!passenger.hasNullCallback())
+                this.gameEvent(GameEvent.ENTITY_MOUNT, passenger); // Folia - region threading - do not fire game events for entities not added
         }
     }
 
     // Paper start
-    protected boolean removePassenger(Entity entity) { return removePassenger(entity, false);}
+    protected boolean removePassenger(Entity entity) {
+        return removePassenger(entity, false);
+    }
+
     protected boolean removePassenger(Entity entity, boolean suppressCancellation) { // CraftBukkit
         // Paper end
         if (entity.getVehicle() == this) {
@@ -3026,33 +3064,33 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         } else {
             // CraftBukkit start
             if (this.valid) { // Folia - region threading - suppress entire event logic during worldgen
-            CraftEntity craft = (CraftEntity) entity.getBukkitEntity().getVehicle();
-            Entity orig = craft == null ? null : craft.getHandle();
-            if (this.getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) {
-                VehicleExitEvent event = new VehicleExitEvent(
+                CraftEntity craft = (CraftEntity) entity.getBukkitEntity().getVehicle();
+                Entity orig = craft == null ? null : craft.getHandle();
+                if (this.getBukkitEntity() instanceof Vehicle && entity.getBukkitEntity() instanceof LivingEntity) {
+                    VehicleExitEvent event = new VehicleExitEvent(
                         (Vehicle) this.getBukkitEntity(),
                         (LivingEntity) entity.getBukkitEntity(), !suppressCancellation // Paper
-                );
+                    );
+                    // Suppress during worldgen
+                    if (this.valid) {
+                        Bukkit.getPluginManager().callEvent(event);
+                    }
+                    CraftEntity craftn = (CraftEntity) entity.getBukkitEntity().getVehicle();
+                    Entity n = craftn == null ? null : craftn.getHandle();
+                    if (event.isCancelled() || n != orig) {
+                        return false;
+                    }
+                }
+                // CraftBukkit end
+                // Spigot start
+                org.spigotmc.event.entity.EntityDismountEvent event = new org.spigotmc.event.entity.EntityDismountEvent(entity.getBukkitEntity(), this.getBukkitEntity(), !suppressCancellation); // Paper
                 // Suppress during worldgen
                 if (this.valid) {
                     Bukkit.getPluginManager().callEvent(event);
                 }
-                CraftEntity craftn = (CraftEntity) entity.getBukkitEntity().getVehicle();
-                Entity n = craftn == null ? null : craftn.getHandle();
-                if (event.isCancelled() || n != orig) {
+                if (event.isCancelled()) {
                     return false;
                 }
-            }
-            // CraftBukkit end
-            // Spigot start
-            org.spigotmc.event.entity.EntityDismountEvent event = new org.spigotmc.event.entity.EntityDismountEvent(entity.getBukkitEntity(), this.getBukkitEntity(), !suppressCancellation); // Paper
-            // Suppress during worldgen
-            if (this.valid) {
-                Bukkit.getPluginManager().callEvent(event);
-            }
-            if (event.isCancelled()) {
-                return false;
-            }
             } // Folia - region threading - suppress entire event logic during worldgen
             // Spigot end
             if (this.passengers.size() == 1 && this.passengers.get(0) == entity) {
@@ -3064,7 +3102,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             }
 
             entity.boardingCooldown = 60;
-            if (!entity.hasNullCallback()) this.gameEvent(GameEvent.ENTITY_DISMOUNT, entity); // Folia - region threading - do not fire game events for entities not added
+            if (!entity.hasNullCallback())
+                this.gameEvent(GameEvent.ENTITY_DISMOUNT, entity); // Folia - region threading - do not fire game events for entities not added
         }
         return true; // CraftBukkit
     }
@@ -3165,14 +3204,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                         this.portalTime = 0;
                     } else {
                         worldserver1 = event.getTargetWorld() == null ? null : ((CraftWorld) event.getTargetWorld()).getHandle();
-                    // Paper end
-                    this.setPortalCooldown();
-                    // CraftBukkit start
-                    if (this instanceof ServerPlayer) {
-                        ((ServerPlayer) this).changeDimension(worldserver1, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL);
-                    } else {
-                        this.changeDimension(worldserver1);
-                    }
+                        // Paper end
+                        this.setPortalCooldown();
+                        // CraftBukkit start
+                        if (this instanceof ServerPlayer) {
+                            ((ServerPlayer) this).changeDimension(worldserver1, PlayerTeleportEvent.TeleportCause.NETHER_PORTAL);
+                        } else {
+                            this.changeDimension(worldserver1);
+                        }
                     } // Paper
                     // CraftBukkit end
                     this.level().getProfiler().pop();
@@ -3202,7 +3241,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         this.setDeltaMovement(x, y, z);
     }
 
-    public void handleDamageEvent(DamageSource damageSource) {}
+    public void handleDamageEvent(DamageSource damageSource) {
+    }
 
     public void handleEntityEvent(byte status) {
         switch (status) {
@@ -3212,7 +3252,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         }
     }
 
-    public void animateHurt(float yaw) {}
+    public void animateHurt(float yaw) {
+    }
 
     public Iterable<ItemStack> getHandSlots() {
         return Entity.EMPTY_LIST;
@@ -3226,7 +3267,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return Iterables.concat(this.getHandSlots(), this.getArmorSlots());
     }
 
-    public void setItemSlot(EquipmentSlot slot, ItemStack stack) {}
+    public void setItemSlot(EquipmentSlot slot, ItemStack stack) {
+    }
 
     public boolean isOnFire() {
         boolean flag = this.level() != null && this.level().isClientSide;
@@ -3340,7 +3382,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return false;
     }
 
-    public void updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> callback) {}
+    public void updateDynamicGameEventListener(BiConsumer<DynamicGameEventListener<?>, ServerLevel> callback) {
+    }
 
     @Nullable
     public PlayerTeam getTeam() {
@@ -3349,7 +3392,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             return null;
         }
         // Folia end - region threading
-        if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof Player)) { return null; } // Paper
+        if (!this.level().paperConfig().scoreboards.allowNonPlayerEntitiesOnScoreboards && !(this instanceof Player)) {
+            return null;
+        } // Paper
         return this.level().getScoreboard().getPlayersTeam(this.getScoreboardName());
     }
 
@@ -3443,10 +3488,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             pluginManager.callEvent(entityCombustEvent);
             if (!entityCombustEvent.isCancelled()) {
                 this.setSecondsOnFire(entityCombustEvent.getDuration(), false);
-            // Paper start - fix EntityCombustEvent cancellation.
+                // Paper start - fix EntityCombustEvent cancellation.
             } else {
                 this.setRemainingFireTicks(this.remainingFireTicks - 1);
-            // Paper end
+                // Paper end
             }
             // CraftBukkit end
         }
@@ -3589,9 +3634,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return 0.0F;
     }
 
-    public void setYHeadRot(float headYaw) {}
+    public void setYHeadRot(float headYaw) {
+    }
 
-    public void setYBodyRot(float bodyYaw) {}
+    public void setYBodyRot(float bodyYaw) {
+    }
 
     public boolean isAttackable() {
         return true;
@@ -4023,7 +4070,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
         EntityTreeNode passengerTree = this.detachPassengers();
         List<EntityTreeNode> fullPassengerTree = passengerTree.getFullTree();
-        ServerLevel originWorld = (ServerLevel)this.level;
+        ServerLevel originWorld = (ServerLevel) this.level;
 
         for (EntityTreeNode node : fullPassengerTree) {
             node.root.preChangeDimension();
@@ -4151,7 +4198,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
                             // the portal obsidian is placed at targetPos.y - 2, so if we want to place the entity
                             // on the obsidian, we need to spawn at targetPos.y - 1
-                            if (FoldenorConfig.vanilaEndPortalTeleportation){
+                            if (FoldenorConfig.vanilaEndPortalTeleportation) {
                                 Vec3 finalPos;
                                 if (this instanceof Player) finalPos = Vec3.atBottomCenterOf(targetPos.below());
                                 else finalPos = Vec3.atBottomCenterOf(targetPos);
@@ -4159,8 +4206,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                                 portalInfoCompletable.complete(
                                     new PortalInfo(finalPos, this.getDeltaMovement(), 90.0f, 0.0f, destination, null) // Kaiiju - Vanilla end teleportation
                                 );
-                            }
-                            else{
+                            } else {
                                 // the portal obsidian is placed at targetPos.y - 2, so if we want to place the entity
                                 // on the obsidian, we need to spawn at targetPos.y - 1
                                 portalInfoCompletable.complete(
@@ -4201,16 +4247,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
                     originalPortalBlock == null || !originalPortalBlock.hasProperty(BlockStateProperties.HORIZONTAL_AXIS)
                         ? null
                         : BlockUtil.getLargestRectangleAround(
-                            this.portalEntrancePos, originalPortalDirection, 21, Direction.Axis.Y, 21,
-                            (blockpos) -> {
-                                return origin.getBlockStateFromEmptyChunkIfLoaded(blockpos) == originalPortalBlock;
-                            }
-                        );
+                        this.portalEntrancePos, originalPortalDirection, 21, Direction.Axis.Y, 21,
+                        (blockpos) -> {
+                            return origin.getBlockStateFromEmptyChunkIfLoaded(blockpos) == originalPortalBlock;
+                        }
+                    );
 
                 boolean destinationIsNether = destination.getTypeKey() == LevelStem.NETHER;
 
                 int portalSearchRadius = origin.paperConfig().environment.portalSearchVanillaDimensionScaling && destinationIsNether ?
-                    (int)(destination.paperConfig().environment.portalSearchRadius / destination.dimensionType().coordinateScale()) :
+                    (int) (destination.paperConfig().environment.portalSearchRadius / destination.dimensionType().coordinateScale()) :
                     destination.paperConfig().environment.portalSearchRadius;
                 int portalCreateRadius = destination.paperConfig().environment.portalCreateRadius;
 
@@ -4362,7 +4408,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         // first, remove entity/passengers from world
         EntityTreeNode passengerTree = this.detachPassengers();
         List<EntityTreeNode> fullPassengerTree = passengerTree.getFullTree();
-        ServerLevel originWorld = (ServerLevel)this.level;
+        ServerLevel originWorld = (ServerLevel) this.level;
 
         for (EntityTreeNode node : fullPassengerTree) {
             node.root.preChangeDimension();
@@ -4828,7 +4874,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return this.isCustomNameVisible();
     }
 
-    public void onSyncedDataUpdated(List<SynchedEntityData.DataValue<?>> dataEntries) {}
+    public void onSyncedDataUpdated(List<SynchedEntityData.DataValue<?>> dataEntries) {
+    }
 
     public void onSyncedDataUpdated(EntityDataAccessor<?> data) {
         if (Entity.DATA_POSE.equals(data)) {
@@ -4837,7 +4884,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     }
 
-    /** @deprecated */
+    /**
+     * @deprecated
+     */
     @Deprecated
     protected void fixupDimensions() {
         net.minecraft.world.entity.Pose entitypose = this.getPose();
@@ -4898,11 +4947,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public final void setBoundingBox(AABB boundingBox) {
         // CraftBukkit start - block invalid bounding boxes
         double minX = boundingBox.minX,
-                minY = boundingBox.minY,
-                minZ = boundingBox.minZ,
-                maxX = boundingBox.maxX,
-                maxY = boundingBox.maxY,
-                maxZ = boundingBox.maxZ;
+            minY = boundingBox.minY,
+            minZ = boundingBox.minZ,
+            maxX = boundingBox.maxX,
+            maxY = boundingBox.maxY,
+            maxZ = boundingBox.maxZ;
         double len = boundingBox.maxX - boundingBox.minX;
         if (len < 0) maxX = minX;
         if (len > 64) maxX = minX + 64.0;
@@ -4943,7 +4992,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     }
 
     @Override
-    public void sendSystemMessage(Component message) {}
+    public void sendSystemMessage(Component message) {
+    }
 
     public Level getCommandSenderWorld() {
         return this.level();
@@ -4970,9 +5020,11 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         EnchantmentHelper.doPostDamageEffects(attacker, target);
     }
 
-    public void startSeenByPlayer(ServerPlayer player) {}
+    public void startSeenByPlayer(ServerPlayer player) {
+    }
 
-    public void stopSeenByPlayer(ServerPlayer player) {}
+    public void stopSeenByPlayer(ServerPlayer player) {
+    }
 
     public float rotate(Rotation rotation) {
         float f = Mth.wrapDegrees(this.getYRot());
@@ -5045,25 +5097,33 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     }
 
     private Stream<Entity> getIndirectPassengersStream() {
-        if (this.passengers.isEmpty()) { return Stream.of(); } // Paper
+        if (this.passengers.isEmpty()) {
+            return Stream.of();
+        } // Paper
         return this.passengers.stream().flatMap(Entity::getSelfAndPassengers);
     }
 
     @Override
     public Stream<Entity> getSelfAndPassengers() {
-        if (this.passengers.isEmpty()) { return Stream.of(this); } // Paper
+        if (this.passengers.isEmpty()) {
+            return Stream.of(this);
+        } // Paper
         return Stream.concat(Stream.of(this), this.getIndirectPassengersStream());
     }
 
     @Override
     public Stream<Entity> getPassengersAndSelf() {
-        if (this.passengers.isEmpty()) { return Stream.of(this); } // Paper
+        if (this.passengers.isEmpty()) {
+            return Stream.of(this);
+        } // Paper
         return Stream.concat(this.passengers.stream().flatMap(Entity::getPassengersAndSelf), Stream.of(this));
     }
 
     public Iterable<Entity> getIndirectPassengers() {
         // Paper start - rewrite this method
-        if (this.passengers.isEmpty()) { return ImmutableList.of(); }
+        if (this.passengers.isEmpty()) {
+            return ImmutableList.of();
+        }
         ImmutableList.Builder<Entity> indirectPassengers = ImmutableList.builder();
         for (Entity passenger : this.passengers) {
             indirectPassengers.add(passenger);
@@ -5071,6 +5131,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         }
         return indirectPassengers.build();
     }
+
     private Iterable<Entity> getIndirectPassengers_old() {
         // Paper end
         return () -> {
@@ -5087,7 +5148,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     // Paper start - rewrite chunk system
     public boolean hasAnyPlayerPassengers() {
         // copied from below
-        if (this.passengers.isEmpty()) { return false; }
+        if (this.passengers.isEmpty()) {
+            return false;
+        }
         return this.getIndirectPassengersStream().anyMatch((entity) -> {
             return entity instanceof Player;
         });
@@ -5095,7 +5158,9 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     // Paper end - rewrite chunk system
 
     public boolean hasExactlyOnePlayerPassenger() {
-        if (this.passengers.isEmpty()) { return false; } // Paper
+        if (this.passengers.isEmpty()) {
+            return false;
+        } // Paper
         return this.countPlayerPassengers() == 1;
     }
 
@@ -5216,16 +5281,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     }
 
     public boolean updateFluidHeightAndDoFluidPushing(TagKey<Fluid> tag, double speed) {
-        if (this.touchingUnloadedChunk()) {
+        if (false && this.touchingUnloadedChunk()) {
             return false;
         } else {
             AABB axisalignedbb = this.getBoundingBox().deflate(0.001D);
-            int i = Mth.floor(axisalignedbb.minX);
-            int j = Mth.ceil(axisalignedbb.maxX);
-            int k = Mth.floor(axisalignedbb.minY);
-            int l = Mth.ceil(axisalignedbb.maxY);
-            int i1 = Mth.floor(axisalignedbb.minZ);
-            int j1 = Mth.ceil(axisalignedbb.maxZ);
+            int minBlockX = Mth.floor(axisalignedbb.minX);
+            int maxBlockX = Mth.ceil(axisalignedbb.maxX);
+            int minBlockY = Mth.floor(axisalignedbb.minY);
+            int maxBlockY = Mth.ceil(axisalignedbb.maxY);
+            int minBlockZ = Mth.floor(axisalignedbb.minZ);
+            int maxBlockZ = Mth.ceil(axisalignedbb.maxZ);
             double d1 = 0.0D;
             boolean flag = this.isPushedByFluid();
             boolean flag1 = false;
@@ -5233,33 +5298,81 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             int k1 = 0;
             BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-            for (int l1 = i; l1 < j; ++l1) {
-                for (int i2 = k; i2 < l; ++i2) {
-                    for (int j2 = i1; j2 < j1; ++j2) {
-                        blockposition_mutableblockposition.set(l1, i2, j2);
-                        FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
+            final int minSection = io.papermc.paper.util.WorldUtil.getMinSection(this.level);
+            final int maxSection = io.papermc.paper.util.WorldUtil.getMaxSection(this.level);
+            final int minBlock = minSection << 4;
+            final int maxBlock = (maxSection << 4) | 15;
+
+            // special cases:
+            if (minBlockY > maxBlock || maxBlockY < minBlock) {
+                // no point in checking
+                return false;
+            }
+
+            int minYIterate = Math.max(minBlock, minBlockY);
+            int maxYIterate = Math.min(maxBlock, maxBlockY);
 
-                        if (fluid.is(tag)) {
-                            double d2 = (double) ((float) i2 + fluid.getHeight(this.level(), blockposition_mutableblockposition));
+            int minChunkX = minBlockX >> 4;
+            int maxChunkX = maxBlockX >> 4;
 
-                            if (d2 >= axisalignedbb.minY) {
-                                flag1 = true;
-                                d1 = Math.max(d2 - axisalignedbb.minY, d1);
-                                if (flag) {
-                                    Vec3 vec3d1 = fluid.getFlow(this.level(), blockposition_mutableblockposition);
+            int minChunkZ = minBlockZ >> 4;
+            int maxChunkZ = maxBlockZ >> 4;
 
-                                    if (d1 < 0.4D) {
-                                        vec3d1 = vec3d1.scale(d1);
-                                    }
+            for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                int minZ = currChunkZ == minChunkZ ? minBlockZ & 15 : 0; // coordinate in chunk
+                int maxZ = currChunkZ == maxChunkZ ? maxBlockZ & 15 : 16; // coordinate in chunk
 
-                                    vec3d = vec3d.add(vec3d1);
-                                    ++k1;
-                                }
-                                // CraftBukkit start - store last lava contact location
-                                if (tag == FluidTags.LAVA) {
-                                    this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+                    int minX = currChunkX == minChunkX ? minBlockX & 15 : 0; // coordinate in chunk
+                    int maxX = currChunkX == maxChunkX ? maxBlockX & 15 : 16; // coordinate in chunk
+
+                    net.minecraft.world.level.chunk.ChunkAccess chunk = this.level.getChunkIfLoadedImmediately(currChunkX, currChunkZ);
+                    if (chunk == null) {
+                        return false; // if we're touching an unloaded chunk then it's false
+                    }
+
+                    net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunk.getSections();
+
+                    for (int currY = minYIterate; currY < maxYIterate; ++currY) {
+                        net.minecraft.world.level.chunk.LevelChunkSection section = sections[(currY >> 4) - minSection];
+
+                        if (section == null || section.hasOnlyAir() || section.fluidStateCount == 0) { // if no fluids, nothing in this section
+                            // empty
+                            // skip to next section
+                            currY = (currY & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
+                            continue;
+                        }
+
+                        net.minecraft.world.level.chunk.PalettedContainer<BlockState> blocks = section.states;
+
+                        for (int currZ = minZ; currZ < maxZ; ++currZ) {
+                            for (int currX = minX; currX < maxX; ++currX) {
+                                FluidState fluid = blocks.get(currX & 15, currY & 15, currZ & 15).getFluidState();
+
+                                if (fluid.is(tag)) {
+                                    blockposition_mutableblockposition.set((currChunkX << 4) + currX, currY, (currChunkZ << 4) + currZ);
+                                    double d2 = (double) ((float) currY + fluid.getHeight(this.level, blockposition_mutableblockposition));
+
+                                    if (d2 >= axisalignedbb.minY) {
+                                        flag1 = true;
+                                        d1 = Math.max(d2 - axisalignedbb.minY, d1);
+                                        if (flag) {
+                                            Vec3 vec3d1 = fluid.getFlow(this.level, blockposition_mutableblockposition);
+
+                                            if (d1 < 0.4D) {
+                                                vec3d1 = vec3d1.scale(d1);
+                                            }
+
+                                            vec3d = vec3d.add(vec3d1);
+                                            ++k1;
+                                        }
+                                        // CraftBukkit start - store last lava contact location
+                                        if (tag == FluidTags.LAVA) {
+                                            this.lastLavaContact = blockposition_mutableblockposition.immutable();
+                                        }
+                                        // CraftBukkit end
+                                    }
                                 }
-                                // CraftBukkit end
                             }
                         }
                     }
@@ -5361,7 +5474,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
 
     public void setDeltaMovement(Vec3 velocity) {
         synchronized (this.posLock) { // Paper
-        this.deltaMovement = velocity;
+            this.deltaMovement = velocity;
         } // Paper
     }
 
@@ -5446,6 +5559,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         // Paper start
         this.setPosRaw(x, y, z, false);
     }
+
     public final void setPosRaw(double x, double y, double z, boolean forceBoundingBoxUpdate) {
         // Paper start - block invalid positions
         if (!checkPosition(this, x, y, z)) {
@@ -5472,7 +5586,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         boolean posChanged = this.position.x != x || this.position.y != y || this.position.z != z; // Folia - region threading
         if (posChanged) { // Folia - region threading
             synchronized (this.posLock) { // Paper
-            this.position = new Vec3(x, y, z);
+                this.position = new Vec3(x, y, z);
             } // Paper
             int i = Mth.floor(x);
             int j = Mth.floor(y);
@@ -5497,7 +5611,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         // Paper end
     }
 
-    public void checkDespawn() {}
+    public void checkDespawn() {
+    }
 
     public Vec3 getRopeHoldPosition(float delta) {
         return this.getPosition(delta).add(0.0D, (double) this.eyeHeight * 0.7D, 0.0D);
@@ -5593,7 +5708,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     public final void setRemoved(Entity.RemovalReason reason) {
         // Paper start - rewrite chunk system
         io.papermc.paper.util.TickThread.ensureTickThread(this, "Cannot remove entity off-main");
-        if (!((ServerLevel)this.level).getEntityLookup().canRemoveEntity(this)) {
+        if (!((ServerLevel) this.level).getEntityLookup().canRemoveEntity(this)) {
             LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
             return;
         }
@@ -5610,7 +5725,8 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
             this.stopRiding();
         }
 
-        if (reason != RemovalReason.UNLOADED_TO_CHUNK) this.getPassengers().forEach(Entity::stopRiding); // Paper - chunk system - don't adjust passenger state when unloading, it's just not safe (and messes with our logic in entity chunk unload)
+        if (reason != RemovalReason.UNLOADED_TO_CHUNK)
+            this.getPassengers().forEach(Entity::stopRiding); // Paper - chunk system - don't adjust passenger state when unloading, it's just not safe (and messes with our logic in entity chunk unload)
         this.levelCallback.onRemove(reason);
         // Paper start - Folia schedulers
         if (!(this instanceof ServerPlayer) && reason != RemovalReason.CHANGED_DIMENSION && !alreadyRemoved) {
@@ -5625,10 +5741,12 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     }
 
     // Folia start - region threading
-    protected void preRemove(Entity.RemovalReason reason) {}
+    protected void preRemove(Entity.RemovalReason reason) {
+    }
     // Folia end - region threading
 
     // Paper start - Folia schedulers
+
     /**
      * Invoked only when the entity is truly removed from the server, never to be added to any world.
      */
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index f0de72afad4bb571153436399386a6a8a70582a6..199d618a5608e584f6faa9f47834970b4c92eb54 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -25,6 +25,7 @@ public class LevelChunkSection {
     public final PalettedContainer<BlockState> states;
     // CraftBukkit start - read/write
     private PalettedContainer<Holder<Biome>> biomes;
+    public short fluidStateCount;
     public final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
     // Paper start - optimise collisions
     private int specialCollidingBlocks;
@@ -102,6 +103,7 @@ public class LevelChunkSection {
 
         if (!fluid.isEmpty()) {
             --this.tickingFluidCount;
+            --this.fluidStateCount;
         }
 
         if (!state.isAir()) {
@@ -116,6 +118,7 @@ public class LevelChunkSection {
 
         if (!fluid1.isEmpty()) {
             ++this.tickingFluidCount;
+            ++this.fluidStateCount;
         }
 
         this.updateBlockCallback(x, y, z, iblockdata1, state); // Paper - optimise collisions
@@ -161,6 +164,7 @@ public class LevelChunkSection {
                 if (fluid.isRandomlyTicking()) {
                     this.tickingFluidCount = (short) (this.tickingFluidCount + 1);
                 }
+                this.fluidStateCount++;
             }
 
             // Paper start - optimise collisions
