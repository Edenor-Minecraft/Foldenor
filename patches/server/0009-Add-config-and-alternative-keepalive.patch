From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Mon, 10 Jul 2023 13:28:00 +0400
Subject: [PATCH] Add-config-and-alternative-keepalive


diff --git a/src/main/java/net/edenor/foldenor/FoldenorConfig.java b/src/main/java/net/edenor/foldenor/FoldenorConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..1de71ae40f07543d850ef18ec35d6827792ecfd2
--- /dev/null
+++ b/src/main/java/net/edenor/foldenor/FoldenorConfig.java
@@ -0,0 +1,187 @@
+package net.edenor.foldenor;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+public class FoldenorConfig {
+    protected static final String HEADER = "This is the main configuration file for Foldenor.";
+    protected static File CONFIG_FILE;
+    public static YamlConfiguration config;
+
+    public static int version;
+    static boolean verbose;
+
+    public static boolean alternateKeepAlive = false;
+
+    public static int maxProjectileLoadsPerProjectile = 10;
+
+    public static int maxProjectileLoadsPerTick = 10;
+
+    public static void init(File configFile) {
+        init(configFile, true);
+    }
+
+    public static void reload(File configFile) {
+        init(configFile, false);
+    }
+
+    private static void init(File configFile, boolean setup) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        if (configFile.exists()) {
+            try {
+                config.load(CONFIG_FILE);
+            } catch (InvalidConfigurationException ex){
+                Bukkit.getLogger().log(Level.SEVERE, "Could not load foldenor.yml, please correct your syntax errors", ex);
+                throw Throwables.propagate(ex);
+            } catch (IOException ignore) {}
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+
+        readConfig(FoldenorConfig.class, null, setup);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            log(Level.INFO, s);
+        }
+    }
+
+    protected static void log(Level level, String s) {
+        Bukkit.getLogger().log(level, s);
+    }
+
+    static void readConfig(Class<?> clazz, Object instance, boolean setup) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    if (method.getName().endsWith("Setup") && !setup) continue;
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void optimizationSettings() {
+        maxProjectileLoadsPerProjectile = getInt("optimizations.max_projectile_loads_per_projectile",maxProjectileLoadsPerProjectile);
+        maxProjectileLoadsPerTick = getInt("optimizations.max_projectile_loads_per_tick",maxProjectileLoadsPerTick);
+    }
+
+    private static void networkSettings() {
+        alternateKeepAlive = getBoolean("network.alternate-keepalive", alternateKeepAlive);
+    }
+
+    protected static void set(String path, Object val) {
+        config.addDefault(path, val);
+        config.set(path, val);
+    }
+
+    protected static String getString(String path, String def, String... comment) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    protected static boolean getBoolean(String path, boolean def, String... comment) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    protected static double getDouble(String path, double def, String... comment) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    protected static int getInt(String path, int def, String... comment) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    protected static <T> List getList(String path, T def, String... comment) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def, String... comment) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    protected static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    protected static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    protected static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    protected static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    protected static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    protected static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 7abd4f38ae59a6019137345af960fd60a3c7adf0..34820b8a05cf1265f0eeb6e60803e32fbfe9e977 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -19,6 +19,8 @@ import java.util.Locale;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
+
+import net.edenor.foldenor.FoldenorConfig;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
 import net.minecraft.SharedConstants;
@@ -218,6 +220,12 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         thread.start(); // Paper - start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this);
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics();
+        try {
+            FoldenorConfig.init((java.io.File) options.valueOf("foldenor-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 4963e87adf11c9df90f0dd4b60d360a137c07bc9..c402ed70938206d9358d2be8ff81aa1d143b3f94 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -29,6 +29,8 @@ import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import net.edenor.foldenor.FoldenorConfig;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -261,6 +263,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     private long keepAliveTime = Util.getMillis();
     private boolean keepAlivePending;
     private long keepAliveChallenge;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList();
     // CraftBukkit start - multithreaded fields
     private final AtomicInteger chatSpamTickCount = new AtomicInteger();
     private final java.util.concurrent.atomic.AtomicInteger tabSpamLimiter = new java.util.concurrent.atomic.AtomicInteger(); // Paper - configurable tab spam limits
@@ -352,19 +355,41 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         long currentTime = Util.getMillis();
         long elapsedTime = currentTime - this.keepAliveTime;
 
-        if (this.keepAlivePending) {
+        /*if (this.keepAlivePending) {
             if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
                 ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName()); // more info
-                this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
-            }
-        } else {
+                this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause*/
+        if (FoldenorConfig.alternateKeepAlive) {
+            if (elapsedTime >= 1000L) { // 1 second
+                if (!processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
+                    LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName());
+                    disconnect(Component.translatable("disconnect.timeout"), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT);
+                } else {
+                    keepAliveTime = currentTime; // hijack this field for 1 second intervals
+                    keepAlives.add(currentTime); // currentTime is ID
+                    send(new ClientboundKeepAlivePacket(currentTime));
+                }
+        }
+        /*} else {
             if (elapsedTime >= 15000L) { // 15 seconds
                 this.keepAlivePending = true;
                 this.keepAliveTime = currentTime;
                 this.keepAliveChallenge = currentTime;
-                this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));
+                this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));*/
+        } else
+            if (this.keepAlivePending) {
+                if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
+                    ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName()); // more info
+                    this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
+                }
+            } else {
+                if (elapsedTime >= 15000L) { // 15 seconds
+                    this.keepAlivePending = true;
+                    this.keepAliveTime = currentTime;
+                    this.keepAliveChallenge = currentTime;
+                    this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));
+                }
             }
-        }
     }
     // Folia end - region threading
 
@@ -3535,7 +3560,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
         //PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel()); // CraftBukkit // Paper - This shouldn't be on the main thread
-        if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
+        /*if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int) (Util.getMillis() - this.keepAliveTime);
 
             this.player.latency = (this.player.latency * 3 + i) / 4;
@@ -3546,8 +3571,29 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
             this.disconnect(Component.translatable("disconnect.timeout"), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
             // Folia - region threading - do not schedule to main anymore, there is no main
             // Paper end
-        }
-
+        }*/
+
+        if (FoldenorConfig.alternateKeepAlive) {
+            long id = packet.getId();
+            if (keepAlives.size() > 0 && keepAlives.contains(id)) {
+                int ping = (int) (Util.getMillis() - id);
+                player.latency = (player.latency * 3 + ping) / 4;
+                keepAlives.clear(); // we got a valid response, lets roll with it and forget the rest
+            }
+        } else
+            //PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // CraftBukkit // Paper - This shouldn't be on the main thread
+            if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
+                int i = (int) (Util.getMillis() - this.keepAliveTime);
+
+                this.player.latency = (this.player.latency * 3 + i) / 4;
+                this.keepAlivePending = false;
+            } else if (!this.isSingleplayerOwner()) {
+                // Paper start - This needs to be handled on the main thread for plugins
+                // Folia - region threading - do not schedule to main anymore, there is no main
+                this.disconnect(Component.translatable("disconnect.timeout"), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
+                // Folia - region threading - do not schedule to main anymore, there is no main
+                // Paper end
+            }
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 7899447859bfc1da81be0945740faa333566b9b6..c6b9714c801647690b1cb1677b6a296b2a4a43eb 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -42,6 +42,7 @@ import java.util.logging.Logger;
 import java.util.stream.Collectors;
 import javax.imageio.ImageIO;
 
+import net.edenor.foldenor.FoldenorConfig;
 import net.edenor.foldenor.Globals;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.commands.CommandSourceStack;
@@ -913,6 +914,10 @@ public final class CraftServer implements Server {
         return this.scheduler;
     }
 
+    public YamlConfiguration getFoldenorConfig() {
+        return FoldenorConfig.config;
+    }
+
     @Override
     public ServicesManager getServicesManager() {
         return this.servicesManager;
@@ -1069,6 +1074,7 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
+        net.edenor.foldenor.FoldenorConfig.init((File) console.options.valueOf("foldenor-settings"));
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters, config.spawnAnimals); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 4966a1e3dd35357a8ea6a7d2944c84c9c3e9058e..197edc8a577e3ead764e798e46b610b4ff221819 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -173,6 +173,12 @@ public class Main {
                         .describedAs("Jar file");
                 // Paper end
 
+                acceptsAll(asList("foldenor", "foldenor-settings"), "File for foldenor settings")
+                    .withRequiredArg()
+                    .ofType(File.class)
+                    .defaultsTo(new File("foldenor.yml"))
+                    .describedAs("Yml file");
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
