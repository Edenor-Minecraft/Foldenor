From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Thu, 4 Jan 2024 16:26:25 +0400
Subject: [PATCH] Luminol-Optimize-mob-spawning-Async-mob-spawn-state-calc


diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
index 41b9405d6759d865e0d14dd4f95163e9690e967d..c3a1a3e00830b7977d0166d0bf3d688dad99d19f 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -26,7 +26,7 @@ public abstract class AreaMap<E> {
 
     // we use linked for better iteration.
     // map of: coordinate to set of objects in coordinate
-    protected final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
+    protected Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
     protected final PooledLinkedHashSets<E> pooledHashSets;
 
     protected final ChangeCallback<E> addCallback;
@@ -160,7 +160,8 @@ public abstract class AreaMap<E> {
     protected abstract PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getEmptySetFor(final E object);
 
     // expensive op, only for debug
-    protected void validate(final E object, final int viewDistance) {
+    protected void validate0(final E object, final int viewDistance) {
+        if (true) throw new UnsupportedOperationException();
         int entiesGot = 0;
         int expectedEntries = (2 * viewDistance + 1);
         expectedEntries *= expectedEntries;
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
index 46954db7ecd35ac4018fdf476df7c8020d7ce6c8..2d9f1c9e5eb1e4260f7a74ef3b35d29ff4173229 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
@@ -5,7 +5,7 @@ import net.minecraft.server.level.ServerPlayer;
 /**
  * @author Spottedleaf
  */
-public final class PlayerAreaMap extends AreaMap<ServerPlayer> {
+public class PlayerAreaMap extends AreaMap<ServerPlayer> {
 
     public PlayerAreaMap() {
         super();
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/AsyncPlayerAreaMap.java b/src/main/java/gg/pufferfish/pufferfish/util/AsyncPlayerAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..d303fc17324de175cffd167aee67ba72e60a810e
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/AsyncPlayerAreaMap.java
@@ -0,0 +1,33 @@
+package gg.pufferfish.pufferfish.util;
+
+import com.destroystokyo.paper.util.misc.PlayerAreaMap;
+import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+import net.minecraft.server.level.ServerPlayer;
+
+public final class AsyncPlayerAreaMap extends PlayerAreaMap {
+
+    public AsyncPlayerAreaMap() {
+        super();
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
+        super(pooledHashSets);
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+                              final ChangeCallback<ServerPlayer> removeCallback) {
+        this(pooledHashSets, addCallback, removeCallback, null);
+    }
+
+    public AsyncPlayerAreaMap(final PooledLinkedHashSets<ServerPlayer> pooledHashSets, final ChangeCallback<ServerPlayer> addCallback,
+                              final ChangeCallback<ServerPlayer> removeCallback, final ChangeSourceCallback<ServerPlayer> changeSourceCallback) {
+        super(pooledHashSets, addCallback, removeCallback, changeSourceCallback);
+        this.areaMap = new Long2ObjectOpenHashMapWrapper<>(new ConcurrentHashMap<>(1024, 0.7f));
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/Long2ObjectOpenHashMapWrapper.java b/src/main/java/gg/pufferfish/pufferfish/util/Long2ObjectOpenHashMapWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..5578acce073cea8a60619e634b3862624c8a1ae8
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/Long2ObjectOpenHashMapWrapper.java
@@ -0,0 +1,42 @@
+package gg.pufferfish.pufferfish.util;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+
+import java.util.Map;
+
+import org.jetbrains.annotations.Nullable;
+
+public class Long2ObjectOpenHashMapWrapper<V> extends Long2ObjectOpenHashMap<V> {
+
+    private final Map<Long, V> backingMap;
+
+    public Long2ObjectOpenHashMapWrapper(Map<Long, V> map) {
+        backingMap = map;
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        return backingMap.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return backingMap.get(key);
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backingMap.remove(key);
+    }
+
+    @Nullable
+    @Override
+    public V putIfAbsent(Long key, V value) {
+        return backingMap.putIfAbsent(key, value);
+    }
+
+    @Override
+    public int size() {
+        return backingMap.size();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 7ca275826609bcf96f103a8c50beaa47c3b4068b..af6a77cfeac2b63dd63d02c561c0a5a6f0ad088f 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -4,6 +4,7 @@ import com.destroystokyo.paper.util.maplist.ReferenceList;
 import com.destroystokyo.paper.util.misc.PlayerAreaMap;
 import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
 import com.mojang.logging.LogUtils;
+import gg.pufferfish.pufferfish.util.AsyncPlayerAreaMap;
 import io.papermc.paper.chunk.system.scheduling.ChunkHolderManager;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
@@ -14,6 +15,7 @@ import it.unimi.dsi.fastutil.longs.Long2ReferenceMap;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.edenor.foldenor.config.FoldenorConfig;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
@@ -58,6 +60,10 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 
@@ -145,6 +151,8 @@ public final class RegionizedWorldData {
                 into.wanderingTraderSpawnDelay = Math.max(from.wanderingTraderSpawnDelay, into.wanderingTraderSpawnDelay);
                 into.wanderingTraderSpawnChance = Math.max(from.wanderingTraderSpawnChance, into.wanderingTraderSpawnChance);
             }
+
+            from.lastAsyncSpawnStateTask = null;
         }
 
         @Override
@@ -302,6 +310,7 @@ public final class RegionizedWorldData {
                 regionizedWorldData.wanderingTraderSpawnDelay = from.wanderingTraderSpawnDelay;
                 regionizedWorldData.villageSiegeState = new VillageSiegeState(); // just re set it, as the spawn pos will be invalid
             }
+            from.lastAsyncSpawnStateTask = null;
         }
     };
 
@@ -398,6 +407,20 @@ public final class RegionizedWorldData {
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos;
     public final Long2IntOpenHashMap chunksBeingWorkedOn = new Long2IntOpenHashMap();
 
+    public volatile CompletableFuture<NaturalSpawner.SpawnState> lastAsyncSpawnStateTask = null;
+    public static ThreadPoolExecutor ASYNC_MOB_SPAWNING_EXECUTOR;
+    public static void initMobSpawningExecutor(){
+        if (FoldenorConfig.enableAsyncMobSpawning){
+            ASYNC_MOB_SPAWNING_EXECUTOR = new ThreadPoolExecutor(
+                1,
+                Integer.MAX_VALUE,
+                1,
+                TimeUnit.MINUTES,
+                new LinkedBlockingQueue<>()
+            );
+        }
+    }
+
     public static final class TempCollisionList<T> {
         final UnsafeList<T> list = new UnsafeList<>(64);
         boolean inUse;
@@ -430,7 +453,7 @@ public final class RegionizedWorldData {
 
     // Mob spawning
     private final PooledLinkedHashSets<ServerPlayer> pooledHashSets = new PooledLinkedHashSets<>();
-    public final PlayerAreaMap mobSpawnMap = new PlayerAreaMap(this.pooledHashSets);
+    public final PlayerAreaMap mobSpawnMap = new AsyncPlayerAreaMap(this.pooledHashSets);
     public int catSpawnerNextTick = 0;
     public int patrolSpawnerNextTick = 0;
     public int phantomSpawnerNextTick = 0;
diff --git a/src/main/java/me/earthme/luminol/utils/AsyncMobSpawnExecutor.java b/src/main/java/me/earthme/luminol/utils/AsyncMobSpawnExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..f8e9e4c964145766f398a7adf7de9e4be2f986e1
--- /dev/null
+++ b/src/main/java/me/earthme/luminol/utils/AsyncMobSpawnExecutor.java
@@ -0,0 +1,71 @@
+package me.earthme.luminol.utils;
+
+import ca.spottedleaf.concurrentutil.collection.MultiThreadedQueue;
+import net.minecraft.server.MinecraftServer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
+
+public class AsyncMobSpawnExecutor implements Runnable, Executor {
+    private final MultiThreadedQueue<Runnable> allTasks = new MultiThreadedQueue<>();
+    private final Thread worker = new Thread(this);
+    private AtomicBoolean shouldRunNext = new AtomicBoolean(true);
+    private AtomicBoolean isRunning = new AtomicBoolean(false);
+    private AtomicBoolean isIdle = new AtomicBoolean(false);
+
+    public boolean isRunning() {
+        return this.isRunning.get();
+    }
+
+    public void startExecutor() {
+        this.worker.setDaemon(true);
+        this.worker.setContextClassLoader(MinecraftServer.class.getClassLoader());
+        this.worker.start();
+    }
+
+    public void forceTerminate() {
+        this.shouldRunNext.set(false);
+        if (this.isRunning.get()) {
+            this.allTasks.clear();
+            LockSupport.unpark(this.worker);
+        }
+    }
+
+    public void dropAllTasks() {
+        this.allTasks.clear();
+    }
+
+    @Override
+    public void run() {
+        this.isRunning.set(true);
+        try {
+            while (this.shouldRunNext.get()) {
+                final Runnable task = this.allTasks.poll();
+                if (task != null) {
+                    this.isIdle.set(false);
+
+                    try {
+                        task.run();
+                    } catch (Exception e) {
+                        e.printStackTrace(); //TODO - Exception processing?
+                    }
+
+                    continue;
+                }
+
+                this.isIdle.set(true);
+                LockSupport.park();
+            }
+        } finally {
+            this.isRunning.set(false);
+        }
+    }
+
+    @Override
+    public void execute(@NotNull Runnable command) {
+        this.allTasks.offer(command);
+        LockSupport.unpark(this.worker); //Notify
+    }
+}
diff --git a/src/main/java/net/edenor/foldenor/config/FoldenorConfig.java b/src/main/java/net/edenor/foldenor/config/FoldenorConfig.java
index c668d7e2c64379e48a12a4c93dbdf18a5ed8cbe7..79073eca74752d550a21f357b5370a76a1457863 100644
--- a/src/main/java/net/edenor/foldenor/config/FoldenorConfig.java
+++ b/src/main/java/net/edenor/foldenor/config/FoldenorConfig.java
@@ -2,6 +2,7 @@ package net.edenor.foldenor.config;
 
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.threadedregions.RegionizedWorldData;
 import net.edenor.foldenor.region.RegionFileFormat;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.ConfigurationSection;
@@ -39,6 +40,8 @@ public class FoldenorConfig {
     public static int acquirePoiForStuckEntityInterval = 60;
     public static boolean enableSuffocationOptimization = true;
 
+    public static boolean enableAsyncMobSpawning = false;
+
     public static RegionFileFormat regionFormatName = RegionFileFormat.ANVIL;
     public static int regionFormatLinearCompressionLevel = 1;
     public static int linearFlushFrequency = 10;
@@ -71,6 +74,9 @@ public class FoldenorConfig {
         set("config-version", 1);
 
         readConfig();
+
+        enableAsyncMobSpawning = getBoolean("optimizations.enable_async_mob_spawning",enableAsyncMobSpawning);
+        RegionizedWorldData.initMobSpawningExecutor();
     }
 
     protected static void log(String s) {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 8082c189fc414b741bff9ca9b259b448e8adf0d2..014e237f6737ac6b5a584d383fbc5219b76786d4 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -4,6 +4,7 @@ import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
@@ -17,6 +18,9 @@ import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+import net.edenor.foldenor.config.FoldenorConfig;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
@@ -107,7 +111,7 @@ public class ServerChunkCache extends ChunkSource {
         if (ret != null) {
             return ret;
         }
-        return (LevelChunk)this.getChunk(x, z, ChunkStatus.FULL, true);
+        return (LevelChunk) this.getChunk(x, z, ChunkStatus.FULL, true);
     }
 
     final java.util.concurrent.atomic.AtomicLong chunkFutureAwaitCounter = new java.util.concurrent.atomic.AtomicLong(); // Paper - private -> package private
@@ -213,7 +217,8 @@ public class ServerChunkCache extends ChunkSource {
     @Nullable
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
-        final int x1 = x; final int z1 = z; // Paper - conflict on variable change
+        final int x1 = x;
+        final int z1 = z; // Paper - conflict on variable change
         if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
@@ -245,7 +250,7 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper end
                 com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.level, x1, z1); // Paper - sync load info
                 this.level.timings.syncChunkLoad.startTiming(); // Paper
-            chunkproviderserver_b.managedBlock(completablefuture::isDone);
+                chunkproviderserver_b.managedBlock(completablefuture::isDone);
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - async chunk debug  // Paper - rewrite chunk system
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
             } // Paper
@@ -305,6 +310,7 @@ public class ServerChunkCache extends ChunkSource {
         // Paper start - add isUrgent - old sig left in place for dirty nms plugins
         return getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create, false);
     }
+
     private CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFutureMainThread(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create, boolean isUrgent) {
         // Paper start - rewrite chunk system
         io.papermc.paper.util.TickThread.ensureTickThread(this.level, chunkX, chunkZ, "Scheduling chunk load off-main");
@@ -398,7 +404,7 @@ public class ServerChunkCache extends ChunkSource {
     public void save(boolean flush) {
         this.runDistanceManagerUpdates();
         try (co.aikar.timings.Timing timed = level.timings.chunkSaveData.startTiming()) { // Paper - Timings
-        this.chunkMap.saveAllChunks(flush);
+            this.chunkMap.saveAllChunks(flush);
         } // Paper - Timings
     }
 
@@ -423,7 +429,8 @@ public class ServerChunkCache extends ChunkSource {
 
     // CraftBukkit start - modelled on below
     public void purgeUnload() {
-        if (true) return; // Paper - tickets will be removed later, this behavior isn't really well accounted for by the chunk system
+        if (true)
+            return; // Paper - tickets will be removed later, this behavior isn't really well accounted for by the chunk system
         this.level.getProfiler().push("purge");
         this.distanceManager.purgeStaleTickets();
         this.runDistanceManagerUpdates();
@@ -439,20 +446,29 @@ public class ServerChunkCache extends ChunkSource {
         final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
         this.level.getProfiler().push("purge");
         this.level.timings.doChunkMap.startTiming(); // Spigot
-        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK); try { // Folia - profiler
-        this.distanceManager.purgeStaleTickets();
-        this.runDistanceManagerUpdates();
-        } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK); } // Folia - profiler
+        profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK);
+        try { // Folia - profiler
+            this.distanceManager.purgeStaleTickets();
+            this.runDistanceManagerUpdates();
+        } finally {
+            profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_HOLDER_MANAGER_TICK);
+        } // Folia - profiler
         this.level.timings.doChunkMap.stopTiming(); // Spigot
         this.level.getProfiler().popPush("chunks");
         if (tickChunks) {
             this.level.timings.chunks.startTiming(); // Paper - timings
-            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK); try { // Folia - profiler
-            this.chunkMap.level.playerChunkLoader.tick(); // Paper - replace player chunk loader - this is mostly required to account for view distance changes
-            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK); } // Folia - profiler
-            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK); try { // Folia - profiler
-            this.tickChunks();
-            } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK); } // Folia - profiler
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK);
+            try { // Folia - profiler
+                this.chunkMap.level.playerChunkLoader.tick(); // Paper - replace player chunk loader - this is mostly required to account for view distance changes
+            } finally {
+                profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLAYER_CHUNK_LOADER_TICK);
+            } // Folia - profiler
+            profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK);
+            try { // Folia - profiler
+                this.tickChunks();
+            } finally {
+                profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.CHUNK_TICK);
+            } // Folia - profiler
             this.level.timings.chunks.stopTiming(); // Paper - timings
             this.chunkMap.tick();
         }
@@ -478,7 +494,8 @@ public class ServerChunkCache extends ChunkSource {
             gameprofilerfiller.push("pollingChunks");
             gameprofilerfiller.push("filteringLoadedChunks");
             // Paper - optimise chunk tick iteration
-            if (this.level.getServer().tickRateManager().runsNormally()) this.level.timings.chunkTicks.startTiming(); // Paper
+            if (this.level.getServer().tickRateManager().runsNormally())
+                this.level.timings.chunkTicks.startTiming(); // Paper
 
             // Paper - optimise chunk tick iteration
 
@@ -488,32 +505,41 @@ public class ServerChunkCache extends ChunkSource {
                 int k = this.distanceManager.getNaturalSpawnChunkCount();
                 // Paper start - per player mob spawning
                 int naturalSpawnChunkCount = k;
-                NaturalSpawner.SpawnState spawnercreature_d; // moved down
-                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT); try { // Folia - profiler
-                if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
-                    // re-set mob counts
-                    for (ServerPlayer player : this.level.getLocalPlayers()) { // Folia - region threading
-                        // Paper start - per player mob spawning backoff
-                        for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
-                            player.mobCounts[ii] = 0;
-
-                            int newBackoff = player.mobBackoffCounts[ii] - 1; // TODO make configurable bleed // TODO use nonlinear algorithm?
-                            if (newBackoff < 0) {
-                                newBackoff = 0;
+                NaturalSpawner.SpawnState spawnercreature_d = null; // moved down
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT);
+                try { // Folia - profiler
+                    if (!FoldenorConfig.enableAsyncMobSpawning) {
+                        if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
+                            // re-set mob counts
+                            for (ServerPlayer player : this.level.getLocalPlayers()) { // Folia - region threading
+                                // Paper start - per player mob spawning backoff
+                                for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
+                                    player.mobCounts[ii] = 0;
+
+                                    int newBackoff = player.mobBackoffCounts[ii] - 1; // TODO make configurable bleed // TODO use nonlinear algorithm?
+                                    if (newBackoff < 0) {
+                                        newBackoff = 0;
+                                    }
+                                    player.mobBackoffCounts[ii] = newBackoff;
+                                    // Paper end - per player mob spawning backoff
+                                }
+
                             }
-                            player.mobBackoffCounts[ii] = newBackoff;
+                            spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, null, true); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
+                        } else {
+                            spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
                         }
-                        // Paper end - per player mob spawning backoff
+                        if (!FoldenorConfig.enableAsyncMobSpawning)
+                            regionizedWorldData.lastAsyncSpawnStateTask = CompletableFuture.completedFuture(spawnercreature_d);
                     }
-                    spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, null, true); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
-                } else {
-                    spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false); // Folia - region threading - note: function only cares about loaded entities, doesn't need all
-                }
-                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT); } // Folia - profiler
+
+                } finally {
+                    profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MOB_SPAWN_ENTITY_COUNT);
+                } // Folia - profiler
                 // Paper end
                 this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
 
-                regionizedWorldData.lastSpawnState = spawnercreature_d; // Folia - region threading
+                //regionizedWorldData.lastSpawnState = spawnercreature_d; // Folia - region threading
                 gameprofilerfiller.popPush("spawnAndTick");
                 boolean flag = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.getLocalPlayers().isEmpty(); // CraftBukkit // Folia - region threadin
 
@@ -530,11 +556,11 @@ public class ServerChunkCache extends ChunkSource {
                     int viewDistance = io.papermc.paper.chunk.system.ChunkSystem.getTickViewDistance(player);
 
                     // copied and modified from isOutisdeRange
-                    int chunkRange = (int)level.spigotConfig.mobSpawnRange;
+                    int chunkRange = (int) level.spigotConfig.mobSpawnRange;
                     chunkRange = (chunkRange > viewDistance) ? viewDistance : chunkRange;
                     chunkRange = (chunkRange > DistanceManager.MOB_SPAWN_RANGE) ? DistanceManager.MOB_SPAWN_RANGE : chunkRange;
 
-                    com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(player.getBukkitEntity(), (byte)chunkRange);
+                    com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(player.getBukkitEntity(), (byte) chunkRange);
                     event.callEvent();
                     if (event.isCancelled() || event.getSpawnRadius() < 0) {
                         regionizedWorldData.mobSpawnMap.remove(player); // Folia - region threading
@@ -548,7 +574,7 @@ public class ServerChunkCache extends ChunkSource {
                     int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkCoordinate(player.getZ());
 
                     regionizedWorldData.mobSpawnMap.addOrUpdate(player, chunkX, chunkZ, range); // Folia - region threading
-                    player.lastEntitySpawnRadiusSquared = (double)((range << 4) * (range << 4)); // used in anyPlayerCloseEnoughForSpawning
+                    player.lastEntitySpawnRadiusSquared = (double) ((range << 4) * (range << 4)); // used in anyPlayerCloseEnoughForSpawning
                     player.playerNaturallySpawnedEvent = event;
                 }
                 // Paper end - optimise chunk tick iteration
@@ -572,56 +598,62 @@ public class ServerChunkCache extends ChunkSource {
                     chunkIterator = shuffled.iterator();
                 }
                 try {
-                // Paper end - optimise chunk tick iteration
-                long spawnChunkCount = 0L; // Folia - profiler
-                long randomChunkCount = 0L; // Folia - profiler
-                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK); try { // Folia - profiler
-                while (chunkIterator.hasNext()) {
-                    LevelChunk chunk1 = chunkIterator.next();
                     // Paper end - optimise chunk tick iteration
-                    ChunkPos chunkcoordintpair = chunk1.getPos();
-
-                    // Paper start - optimise chunk tick iteration
-                    com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
-                        = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
-                    if (playersNearby == null) {
-                        continue;
-                    }
-                    Object[] rawData = playersNearby.getRawData();
-                    boolean spawn = false;
-                    boolean tick = false;
-                    for (int itr = 0, len = playersNearby.size(); itr < len; ++itr) {
-                        ServerPlayer player = (ServerPlayer)rawData[itr];
-                        if (player.isSpectator()) {
-                            continue;
-                        }
-
-                        double distance = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, player);
-                        spawn |= player.lastEntitySpawnRadiusSquared >= distance;
-                        tick |= ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) * ((double)io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) >= distance;
-                        if (spawn & tick) {
-                            break;
-                        }
-                    }
-                    if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
-                        // Paper end - optimise chunk tick iteration
-                        chunk1.incrementInhabitedTime(j);
-                        if (spawn && flag && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
-                            ++spawnChunkCount; // Folia - profiler
-                            NaturalSpawner.spawnForChunk(this.level, chunk1, spawnercreature_d, this.spawnFriendlies, this.spawnEnemies, flag1);
-                        }
-
-                        if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
-                            ++randomChunkCount; // Folia - profiler
-                            this.level.tickChunk(chunk1, l);
-                            if ((chunksTicked++ & 1) == 0) net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
+                    long spawnChunkCount = 0L; // Folia - profiler
+                    long randomChunkCount = 0L; // Folia - profiler
+                    profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK);
+                    try { // Folia - profiler
+                        while (chunkIterator.hasNext()) {
+                            LevelChunk chunk1 = chunkIterator.next();
+                            // Paper end - optimise chunk tick iteration
+                            ChunkPos chunkcoordintpair = chunk1.getPos();
+
+                            // Paper start - optimise chunk tick iteration
+                            com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
+                                = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
+                            if (playersNearby == null) {
+                                continue;
+                            }
+                            Object[] rawData = playersNearby.getRawData();
+                            boolean spawn = false;
+                            boolean tick = false;
+                            for (int itr = 0, len = playersNearby.size(); itr < len; ++itr) {
+                                ServerPlayer player = (ServerPlayer) rawData[itr];
+                                if (player.isSpectator()) {
+                                    continue;
+                                }
+
+                                double distance = ChunkMap.euclideanDistanceSquared(chunkcoordintpair, player);
+                                spawn |= player.lastEntitySpawnRadiusSquared >= distance;
+                                tick |= ((double) io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) * ((double) io.papermc.paper.util.player.NearbyPlayers.SPAWN_RANGE_VIEW_DISTANCE_BLOCKS) >= distance;
+                                if (spawn & tick) {
+                                    break;
+                                }
+                            }
+                            if (tick && chunk1.chunkStatus.isOrAfter(net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING)) {
+                                // Paper end - optimise chunk tick iteration
+                                chunk1.incrementInhabitedTime(j);
+                                if (spawn && flag && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair)) { // Spigot // Paper - optimise chunk tick iteration
+                                    ++spawnChunkCount; // Folia - profiler
+                                    if (regionizedWorldData.lastAsyncSpawnStateTask != null && regionizedWorldData.lastAsyncSpawnStateTask.isDone()) {
+                                        NaturalSpawner.spawnForChunk(this.level, chunk1, regionizedWorldData.lastAsyncSpawnStateTask.join(), this.spawnFriendlies, this.spawnEnemies, flag1);
+                                    }
+                                }
+
+                                if (true || this.level.shouldTickBlocksAt(chunkcoordintpair.toLong())) { // Paper - optimise chunk tick iteration
+                                    ++randomChunkCount; // Folia - profiler
+                                    this.level.tickChunk(chunk1, l);
+                                    if ((chunksTicked++ & 1) == 0)
+                                        net.minecraft.server.MinecraftServer.getServer().executeMidTickTasks(); // Paper
+                                }
+                            }
                         }
-                    }
-                }
-                profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_CHUNK_COUNT, spawnChunkCount); // Folia - profiler
-                profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.RANDOM_CHUNK_TICK_COUNT, randomChunkCount); // Folia - profiler
-                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK); } // Folia - profiler
-                // Paper start - optimise chunk tick iteration
+                        profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_CHUNK_COUNT, spawnChunkCount); // Folia - profiler
+                        profiler.addCounter(ca.spottedleaf.leafprofiler.LProfilerRegistry.RANDOM_CHUNK_TICK_COUNT, randomChunkCount); // Folia - profiler
+                    } finally {
+                        profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.SPAWN_AND_RANDOM_TICK);
+                    } // Folia - profiler
+                    // Paper start - optimise chunk tick iteration
                 } finally {
                     if (chunkIterator instanceof io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet.Iterator safeIterator) {
                         safeIterator.finishedIterating();
@@ -632,37 +664,69 @@ public class ServerChunkCache extends ChunkSource {
 
                 gameprofilerfiller.popPush("customSpawners");
                 if (flag) {
-                    profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK); try { // Folia - profiler
-                    try (co.aikar.timings.Timing ignored = this.level.timings.miscMobSpawning.startTiming()) { // Paper - timings
-                    this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
-                    } // Paper - timings
-                    } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK); } // Folia - profiler
+                    profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK);
+                    try { // Folia - profiler
+                        try (co.aikar.timings.Timing ignored = this.level.timings.miscMobSpawning.startTiming()) { // Paper - timings
+                            this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
+                        } // Paper - timings
+                    } finally {
+                        profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.MISC_MOB_SPAWN_TICK);
+                    } // Folia - profiler
+                }
+                if (FoldenorConfig.enableAsyncMobSpawning) {
+                    if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
+                        // re-set mob counts
+                        for (ServerPlayer player : regionizedWorldData.getLocalPlayers()) { // Folia - region threading
+                            // Paper start - per player mob spawning backoff
+                            for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
+                                player.mobCounts[ii] = 0;
+
+                                int newBackoff = player.mobBackoffCounts[ii] - 1; // TODO make configurable bleed // TODO use nonlinear algorithm?
+                                if (newBackoff < 0) {
+                                    newBackoff = 0;
+                                }
+                                player.mobBackoffCounts[ii] = newBackoff;
+                            }
+                            // Paper end - per player mob spawning backoff
+                        }
+
+                        if (regionizedWorldData.lastAsyncSpawnStateTask == null || regionizedWorldData.lastAsyncSpawnStateTask.isDone()) {
+                            regionizedWorldData.lastAsyncSpawnStateTask = CompletableFuture.supplyAsync(() -> NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, null, true), RegionizedWorldData.ASYNC_MOB_SPAWNING_EXECUTOR);
+                        }
+                    } else {
+                        if (regionizedWorldData.lastAsyncSpawnStateTask == null || regionizedWorldData.lastAsyncSpawnStateTask.isDone()) {
+                            regionizedWorldData.lastAsyncSpawnStateTask = CompletableFuture.supplyAsync(() -> NaturalSpawner.createState(naturalSpawnChunkCount, regionizedWorldData.getLoadedEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false), RegionizedWorldData.ASYNC_MOB_SPAWNING_EXECUTOR);
+                        }
+                    }
                 }
             }
 
             gameprofilerfiller.popPush("broadcast");
             // Paper - optimise chunk tick iteration
-                this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
+            this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing
             // Paper start - optimise chunk tick iteration
             // Folia start - region threading
             if (!this.level.needsChangeBroadcasting.isEmpty()) {
-                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); try { // Folia - profiler
-                for (Iterator<ChunkHolder> iterator = this.level.needsChangeBroadcasting.iterator(); iterator.hasNext();) {
-                    ChunkHolder holder = iterator.next();
-                    if (!io.papermc.paper.util.TickThread.isTickThreadFor(holder.newChunkHolder.world, holder.pos)) {
-                        continue;
-                    }
-                    // don't need to worry about asynchronous chunk holder remove, as that can only be done by this tick thread
-                    holder.broadcastChanges(holder.getFullChunkNowUnchecked());
-                    if (!holder.needsBroadcastChanges()) {
-                        iterator.remove();
+                profiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES);
+                try { // Folia - profiler
+                    for (Iterator<ChunkHolder> iterator = this.level.needsChangeBroadcasting.iterator(); iterator.hasNext(); ) {
+                        ChunkHolder holder = iterator.next();
+                        if (!io.papermc.paper.util.TickThread.isTickThreadFor(holder.newChunkHolder.world, holder.pos)) {
+                            continue;
+                        }
+                        // don't need to worry about asynchronous chunk holder remove, as that can only be done by this tick thread
+                        holder.broadcastChanges(holder.getFullChunkNowUnchecked());
+                        if (!holder.needsBroadcastChanges()) {
+                            iterator.remove();
+                        }
                     }
-                }
-                } finally { profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES); } // Folia - profiler
+                } finally {
+                    profiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.BROADCAST_BLOCK_CHANGES);
+                } // Folia - profiler
             }
             // Folia end - region threading
             // Paper end - optimise chunk tick iteration
-                this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timing
+            this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timing
             // Paper - optimise chunk tick iteration
             gameprofilerfiller.pop();
             gameprofilerfiller.pop();
@@ -809,7 +873,7 @@ public class ServerChunkCache extends ChunkSource {
     @VisibleForDebug
     public NaturalSpawner.SpawnState getLastSpawnState() {
         io.papermc.paper.threadedregions.RegionizedWorldData worldData = this.level.getCurrentWorldData(); // Folia - region threading
-        return worldData == null ? null : worldData.lastSpawnState; // Folia - region threading
+        return worldData.lastAsyncSpawnStateTask != null && worldData.lastAsyncSpawnStateTask.isDone() ? worldData.lastAsyncSpawnStateTask.join() : null; // Folia - region threading
     }
 
     public void removeTicketsOnClosing() {
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index 554844feaf8cb0e43461e1c142bb766c6116fce9..73aac16bd122a90b59b4bb5973c82abe338822c3 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.level;
 
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.objects.Object2IntMap;
 import it.unimi.dsi.fastutil.objects.Object2IntMaps;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -117,6 +119,12 @@ public final class NaturalSpawner {
                     object2intopenhashmap.addTo(enumcreaturetype, 1);
                     // Paper start
                     if (countMobs) {
+                        if (!TickThread.isTickThread()){
+                            RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(chunk.level,chunk.locX,chunk.locZ,()->{
+                                chunk.level.getChunkSource().chunkMap.updatePlayerMobTypeMap(entity);
+                             });
+                            return;
+                         }
                         chunk.level.getChunkSource().chunkMap.updatePlayerMobTypeMap(entity);
                     }
                     // Paper end
