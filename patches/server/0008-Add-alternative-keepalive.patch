From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: AltronMaxX <max06112004@gmail.com>
Date: Sat, 16 Sep 2023 21:26:02 +0400
Subject: [PATCH] Add-alternative-keepalive


diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index a1a931095c41126a05e806541075ccc40b9ea8f9..29ab7c309c928bad143e720412879b2d03d63411 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -29,6 +29,8 @@ import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import net.edenor.foldenor.config.FoldenorConfig;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -265,6 +267,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     private long keepAliveTime = Util.getMillis();
     private boolean keepAlivePending;
     private long keepAliveChallenge;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList();
     // CraftBukkit start - multithreaded fields
     private final AtomicInteger chatSpamTickCount = new AtomicInteger();
     private final java.util.concurrent.atomic.AtomicInteger tabSpamLimiter = new java.util.concurrent.atomic.AtomicInteger(); // Paper - configurable tab spam limits
@@ -357,19 +360,31 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         long currentTime = Util.getMillis();
         long elapsedTime = currentTime - this.keepAliveTime;
 
-        if (this.keepAlivePending) {
-            if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
-                ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName()); // more info
-                this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
+        if (FoldenorConfig.alternateKeepAlive) {
+            if (elapsedTime >= 1000L) { // 1 second
+                if (!processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
+                    LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName());
+                    disconnect(Component.translatable("disconnect.timeout"), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT);
+                } else {
+                    keepAliveTime = currentTime; // hijack this field for 1 second intervals
+                    keepAlives.add(currentTime); // currentTime is ID
+                    send(new ClientboundKeepAlivePacket(currentTime));
+                }
             }
-        } else {
-            if (elapsedTime >= 15000L) { // 15 seconds
-                this.keepAlivePending = true;
-                this.keepAliveTime = currentTime;
-                this.keepAliveChallenge = currentTime;
-                this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));
+        } else
+            if (this.keepAlivePending) {
+                if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
+                    ServerGamePacketListenerImpl.LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName()); // more info
+                    this.disconnect(Component.translatable("disconnect.timeout", new Object[0]), org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
+                }
+            } else {
+                if (elapsedTime >= 15000L) { // 15 seconds
+                    this.keepAlivePending = true;
+                    this.keepAliveTime = currentTime;
+                    this.keepAliveChallenge = currentTime;
+                    this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));
+                }
             }
-        }
     }
     // Folia end - region threading
 
